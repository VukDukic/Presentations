A type-erased wrapper over any collection with indices that support bidirectional traversal. Forwards operations to an arbitrary underlying collection having the same Element type, hiding the specifics of the underlying CollectionType. A wrapper over an underlying BidirectionalIndexType that hides the specific underlying type. A type-erased wrapper over any collection with indices that support forward traversal. Forwards operations to an arbitrary underlying collection having the same Element type, hiding the specifics of the underlying CollectionType. An abstract GeneratorType base class over Element elements. Use this as a Sequence's associated Generator type when you don't want to expose details of the concrete generator, a subclass. It is an error to create instances of AnyGenerator that are not also instances of an AnyGenerator subclass. A type-erased wrapper over any collection with indices that support random access traversal. Forwards operations to an arbitrary underlying collection having the same Element type, hiding the specifics of the underlying CollectionType. A wrapper over an underlying RandomAccessIndexType that hides the specific underlying type. Array is an efficient, tail-growable random-access collection of arbitrary elements. The Array-like type that represents a sub-sequence of any Array, ContiguousArray, or other ArraySlice. ArraySlice always uses contiguous storage and does not bridge to Objective-C. A mutable pointer-to-ObjC-pointer argument. A RandomAccessIndexType that has two possible values. Used as the Index type for CollectionOfOne<T>. A value type whose instances are either true or false. A wrapper around an opaque C pointer. Opaque pointers are used to represent C pointers to types that cannot be represented in Swift, such as incomplete struct types. The corresponding Swift type to va_list in imported C APIs. Character represents some Unicode grapheme cluster as defined by a canonical, localized, or otherwise tailored segmentation algorithm. A closed IntervalType, which contains both its start and its end. Cannot represent an empty interval. Contains a buffer object, and provides access to an instance of Value and contiguous storage for an arbitrary number of Element instances stored in that buffer. For most purposes, the ManagedBuffer class works fine for this purpose, and can simply be used on its own. However, in cases where objects of various different classes must serve as storage, ManagedBufferPointer is needed. A valid buffer class is non-@objc, with no declared stored properties. Its deinit must destroy its stored Value and any constructed Elements. A base class of ManagedBuffer<Value,Element>, used during instance creation. During instance creation, in particular during ManagedBuffer.create's call to initialize, ManagedBuffer's value property is as-yet uninitialized, and therefore ManagedProtoBuffer does not offer access to the as-yet uninitialized value property of ManagedBuffer. Representation of the sub-structure and optional "display style" of any arbitrary subject instance. Describes the parts---such as stored properties, collection elements, tuple elements, or the active enumeration case---that make up a particular instance. May also supply a "display style" property that suggests how this structure might be rendered. Mirrors are used by playgrounds and the debugger. A view into a sub-sequence of elements of another collection. A MutableSlice instance stores the base collection, the start and end indices of the view. It does not copy the elements from the collection into separate storage. Thus, creating a slice has O(1) complexity. A MutableSlice instance inherits the value or reference semantics of the base collection. That is, if a MutableSlice instance is wrapped around a mutable colection that has value semantics (for example, Array), mutating the original collection would not affect the copy stored inside of the slice. A common base class for classes that need to be non-@objc, recognizably in the type system. A collection of consecutive discrete index values. A byte-sized thing that isn't designed to interoperate with any other types; it makes a decent parameter to UnsafeMutablePointer<Memory> when you just want to do bytewise pointer arithmetic. A collection of unique Element instances with no defined ordering. A view into a sub-sequence of elements of another collection. A Slice instance stores the base collection, the start and end indices of the view. It does not copy the elements from the collection into separate storage. Thus, creating a slice has O(1) complexity. A Slice instance inherits the value or reference semantics of the base collection. That is, if a Slice instance is wrapped around a mutable colection that has value semantics (for example, Array), mutating the original collection would not affect the copy stored inside of the slice. An element of a slice is located under the same index in the slice and in the base collection, as long as neither the collection or the slice were mutated. Thus, indices of a slice can be used interchangibly with indices of the base collection. An arbitrary Unicode string value. A SequenceType of values formed by striding over a half-open interval.